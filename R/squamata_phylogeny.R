#' @title Retrieve squamate phylogenies

#' @description This function will retrieve the squamate phylogeny and optionally subset it.

#' @param species a vector of species names that the tree will be subset to, Default: NULL
#' @param genus a vector of genus names that the tree will be subset to, Default: NULL
#' @param family a vector of family names that the tree will be subset to, Default: NULL
#' @param subclade a vector of major squamate subclades that the tree will be subset to, Default: NULL
#' @param type choice of phylogeny to retrieve, see details

#' @return an object of class \code{phylo} or \code{multiPhylo}. If \code{type = 'medianTimeTree'}, then a list is returned with the tree and a table summarizing divergence times. 
#' @details 
#'	The list of major subclades that can be used for subsetting are listed under \code{\link{squamata}}.
#'	
#'	Options for argument \code{type}:
#'	- 'ultrametric': The primary time-calibrated tree, containing 6885 species.
#'	- 'molecular': The primary tree with 6885 species, but with branch lengths representing molecular rates of substition.
#'	- 'unconstrained': An alternative version of the 6885-tip tree, where topology constraints were NOT imposed. 
#'	- 'pseudo-posterior': A set of 100 trees, each with 6885 species, representing variability in backbone topology, divergence times.
#'	- 'genomic': The phylogenomic tree with 1113 species. This topology constrained relationships in the 6885-tip trees.
#'	- 'medianTimeTree': An ultrametric tree with 137 species, resulting the MCMCtree analysis. Here, divergence times are calculated as the median node ages across the posterior distribution of trees. 
#'	- 'timeTreesPost': A posterior distribution of 1000 ultrametric trees, as generated by MCMCtree, with 137 tips.
#' @examples 
#' \dontrun{
#'
#' # get the main 6885-tip squamate phylogeny
#' squamata_phylogeny(type = 'ultrametric')
#' 
#' # get the main tree, but subset to family Phrynosomatidae
#' squamata_phylogeny(type = 'ultrametric', family = 'Phrynosomatidae')
#' 
#' # get the main ultrametric tree subset to genus Lerista and compare it
#' # to the Lerista tree from an topologically unconstrained analysis
#' Lerista_con <- squamata_phylogeny(type = 'ultrametric', genus = 'Lerista')
#' Lerista_uncon <- squamata_phylogeny(type = 'unconstrained', genus = 'Lerista')
#' ape::comparePhylo(Lerista_con, Lerista_uncon)
#' 
#' # get the non-time-calibrated molecular tree for a specified set of species
#' spset <- c('Arrhyton_dolichura', 'Masticophis_bilineatus', 'Protobothrops_cornutus', 
#' 'Mastigodryas_melanolomus', 'Atractus_roulei', 'Dolichophis_jugularis', 'Scincella_vandenburghi', 
#' 'Rhampholeon_beraduccii', 'Liolaemus_azarai', 'Acanthodactylus_bedriagai', 'Boaedon_perisilvestris')
#' squamata_phylogeny(type = 'molecular', species = spset)
#' 
#' # retrieve a pseudo-posterior distribution of 100 trees, all subset to genus Anolis
#' squamata_phylogeny(type = 'pseudo-posterior', genus = 'Anolis')
#' 
#' # get the phylogenomic tree, based on SqCL, AHE and/or UCE loci
#' squamata_phylogeny(type = 'genomic')
#' 
#' # get a time-calibrated phylogeny as generated by MCMCtree, where divergence times are 
#' # set to the median ages across the posterior distribution of divergence times.
#' ## note that this returns a list where the tree is the first item and a table summarizing 
#' ## node ages as the second item. 
#' timetree <- squamata_phylogeny(type = 'medianTimeTree')
#' timetree[[1]]
#' head(timetree[[2]])
#' 
#' # get 1000 random trees from the posterior distribution of the MCMCtree dating analysis.
#' squamata_phylogeny(type = 'timeTreesPost')
#' 
#' }
#' @rdname squamata_phylogeny
#' @export 



squamata_phylogeny <- function(species = NULL, genus = NULL, family = NULL, subclade = NULL, type) {
	
	
	typeOptions <- c('ultrametric', 'molecular', 'unconstrained', 'pseudo-posterior', 'genomic', 'medianTimeTree', 'timeTreesPost')
	type <- match.arg(type, typeOptions)
	
	if (length(type) != 1) {
		stop(paste0("type must be only one of the following: ", paste0(typeOptions, collapse = ', ')))
	}
	
	if (sum(c(is.null(species), is.null(genus), is.null(family), is.null(subclade))) < 3) {
		stop("You cannot subset by more than one taxonomic rank.")
	}

	subCladeOptions <- c('Acrodonta', 'Alethinophidia', 'Amphisbaenia', 'Anguiformes', 'Caenophidia', 'Colubriformes', 'Colubrinae', 'Colubroidea', 'Colubroides', 'Dipsadinae', 'Episquamata', 'Gekkota', 'Iguania', 'Lacertoidea', 'Pleurodonta', 'Scincoidea', 'Scolecophidia', 'Serpentes', 'Teioidea', 'Toxicofera', 'tropicalDipsadines', 'Unidentata')
	
	if (!is.null(subclade)) {
		subclade <- match.arg(subclade, subCladeOptions, several.ok = TRUE)
	}
	
	phy <- .getFile(target = type)
	if (inherits(phy, 'phylo')) {
		phy <- list(phy)
	}
	
	if (!is.null(species)) {
		species <- gsub('^\\s+|\\s+$', '', species)
		species <- gsub('\\s+', '_', species)
	
		if (!all(species %in% phy[[1]]$tip.label)) {
			notInTree <- setdiff(species, phy[[1]]$tip.label)
			notInTree <- paste0('\t', notInTree)
			stop(paste0('The following taxa did not match any tip labels: \n', paste0(notInTree, collapse = '\n')))
		}
		
		phy <- lapply(phy, ape::keep.tip, species)
	}
	
	# if genus or family are provided for subsetting, get the associated species
	if (!is.null(genus) | !is.null(family) | !is.null(subclade)) {

		# get squamdat table
		tax <- .getFile(target = 'squamdat')	
		
		if (!is.null(genus)) {
			genus <- gsub('^\\s+|\\s+$', '', genus)
			species <- tax[which(tax$genus %in% genus), 'treename']
			species <- intersect(species, phy[[1]]$tip.label)
		}
		
		if (!is.null(family)) {
			family <- gsub('^\\s+|\\s+$', '', family)
			species <- tax[which(tax$family %in% family), 'treename']
			species <- intersect(species, phy[[1]]$tip.label)
		}

		if (!is.null(subclade)) {
			subclade <- gsub('^\\s+|\\s+$', '', subclade)
			species <- lapply(subclade, function(x) which(tax[, paste0('clade_', x)] == 1))
			species <- unique(unlist(species))
			species <- tax[species, 'treename']
			species <- intersect(species, phy[[1]]$tip.label)
		}		
	}
	
	# Now subset by species, whether it be derived from genus/family or requested directly
	if (!is.null(species)) {
		species <- gsub('^\\s+|\\s+$', '', species)
		species <- gsub('\\s+', '_', species)
	
		if (!all(species %in% phy[[1]]$tip.label)) {
			notInTree <- setdiff(species, phy[[1]]$tip.label)
			notInTree <- paste0('\t', notInTree)
			stop(paste0('The following taxa did not match any tip labels: \n', paste0(notInTree, collapse = '\n')))
		}
		
		phy <- lapply(phy, ape::keep.tip, species)
	}
	
	
	if (length(phy) == 1) {
		phy <- phy[[1]]
	} else {
		class(phy) <- 'multiPhylo'
	}
	
	if (type == 'medianTimeTree') {
		
		nodeTable <- .subsetDivStats(phy)
		
		return(list(phy, nodeTable))
		
	} else {
		return(phy)
	}
}


